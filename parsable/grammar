@lineComment(";")
@blockComment("/*", "*/")
Start = Rule*

Decorator = "@" [name]ident ("(" ([args]decarg ",")* [args]decarg? ")")? __comment_eol

decarg =
  | bool -- bool
  | string -- string
  | number -- number

@leaf
bool =
  | "true"
  | "false"

Rule =
  | [decorators]Decorator* [name]ident "=" [choices]Choice __comment_eol
  | [decorators]Decorator* [name]ident "=" __comment_eol ("|" [choices]Choice __comment_eol)+

Choice = Item+ (
  "--" [name]ident
)? (
  ";" [comment]rest_of_line
)?

Item = [?neg]"~"&? [?lexify]"#"&? ("["& [flag]flag&? [name]ident &"]")&? [noSpaceBefore]noSpace&? [inner]ItemInner [noSpaceAfter]&noSpace? [suffix]&suffix?

; This rule is only for printing - it doesn't effect parsing at all.
; During printing, it suppresses space if space would be there.
@leaf
noSpace = "&"

ItemInner =
  | string
  | ident
  | "(" NestedItems ")" -- nested
  | char_range
  | char

@passThrough
@ignoreNewlines(true)
NestedItems = [:nested]Item+

char_range = "'" [start]single ".." [end]single "'"
char = "'" [char]single "'"

@leaf
single =
  | "\\" any
  | ~"'" ~'\n' any

@leaf
string = '"' [@contents]strchar* '"'
strchar =
  | "\\" any
  | ~'"' ~'\n' any

flag =
  | "?" -- bool ; exists
  | ":" -- array
  | "@" -- string ; contents

suffix =
  | "+" -- plus
  | "*" -- star
  | "?" -- opt

@leaf
ident = ~digit identchar+
identchar =
  | 'a..z'
  | 'A..Z'
  | '0..9'
  | '_'

@leaf
number =
  | "0" ~identchar
  | ~"0" digit+ ~identchar
digit = '0..9'

@leaf
rest_of_line = (~"\n" any)*

eol = white* eee
eee =
  | eolchar+
  | EOF
eolchar =
  | "\n"
  | "\r"
white =
  | " "
  | "\t"
