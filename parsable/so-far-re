@lineComment("//")
@blockComment("/*", "*/")
Start = ModuleBody

ModuleDesc =
  | "{" ModuleBody "}" -- structure
  | [ident]longCap -- ident
  ; TODO functor
  ; TODO apply
  ; TODO constraint
  ; TODO unpack
  ; TODO extension

@passThrough
@ignoreNewlines(false)
ModuleBody = EOL? ([structure]&Structure EOL)*

Structure =
  | "let" "module" capIdent "=" ModuleDesc -- let_module
  | "let" "rec" "module" capIdent "=" "{" ModuleBody "}" (EOL "and" capIdent "=" "{" ModuleBody "}")* -- let_rec_module
  | "let" [rec]"rec"? [bindings]ValueBinding (EOL "and" [bindings]ValueBinding)* -- value
  | "type" TypeDeclaration (EOL+ "and" TypeDeclaration)* -- type
  | "module" "type" capIdent "=" ModuleTypeDeclaration -- module_type
  | "exception" capIdent "of" Type
  | "import" "*" "from" longCap -- open
  | "include" "*" "from" longCap -- include
  | "[@@@"& lowerIdent &"]" -- attribute
  | "[%%"& lowerIdent &"]" -- extension
  | [expr]Statement [attrs]Attribute* -- eval
  ; class, class type
  ; typeext
  ; external "primitive"

ModuleTypeDeclaration = lowerIdent ; TODO

; TODO class field
; TODO class expr
; TODO class type field
; TODO class type

TypeDeclaration =
  | lowerIdent "=" longIdent "=" TypeDecl -- manifested
  | lowerIdent "=" TypeDecl -- decl
  | lowerIdent -- ident

TypeDecl =
  | TypeVariant
  | TypeRecord
  | Type

@ignoreNewlines(false)
TypeVariant = 
  | "enum" "{" EOL? (TypeVariantItem EOL)* TypeVariantItem? "}"
  | capIdent ("|" capIdent)+ ; should I have this?

TypeVariantItem =
  | "case" capIdent "(" TypesCommad ")"
  | "case" capIdent

@ignoreNewlines
@passThrough
TypesCommad = (Type &",")* Type?

@ignoreNewlines
TypeRecord = "{" (lowerIdent &":" Type ",")* (lowerIdent &":" Type)? "}"

ValueBinding =
  | [name]lowerIdent "("& ValueArgs &")" "=>" Expression -- func
  | [name]lowerIdent Arg "=>" Expression -- func
  | Pattern "=" Expression -- value

@passThrough
@ignoreNewlines
ValueArgs = (Arg &",")* Arg?

Arg =
  | "::"& lowerIdent &ArgValue? -- punned
  | lowerIdent &"::"& Pattern &ArgValue? -- named
  | Pattern -- anon

ArgValue =
  | "=" &"?" -- none
  | "=" &Expression -- expr

Pattern =
  | Pattern "as" lowerIdent
  | Pattern &":" Type
  | "()"
  | "_"
  | "("& Pattern (&"," Pattern)+ &","? &")" -- tuple
  | "["& (Pattern &",")* Pattern? &"]" -- list
  | "{"& (longIdent (&":" Pattern)? &",")* (longIdent (&":" Pattern)?)? &"}" -- record
  | lowerIdent -- ident

MatchPattern =
  | MatchPattern "as" lowerIdent
  | MatchPattern &":" Type
  | "()"
  | "_"
  | MatchPattern "|" MatchPattern -- or
  | "(" MatchPattern &":" Type ")" -- constraint
  | "lazy" MatchPattern -- lazy
  | "exception" MatchPattern -- exception
  | "[%" lowerIdent "]" -- extension
  | char &".."& char -- interval
  | "("& MatchPattern (&"," MatchPattern)+ &","? &")" -- tuple
  | "[|"& (MatchPattern &",")* MatchPattern? &"|]" -- array
  | "["& (MatchPattern &",")* MatchPattern? &"]" -- list ; TODO ...rest
  | "`"&? capIdent &("("& (MatchPattern &",")* MatchPattern? &")")?  -- constructor
  | "{"& (longIdent (&":" MatchPattern)? &",")* (longIdent (&":" MatchPattern)?)? &"}" -- record ; TODO _ for open flag
  | lowerIdent
  | constant
  ; Ppat_type
  ; Ppat_unpack

Type =
  | Type "as" typeVar -- alias
  | "("& TupleTypes &")" -- tuple
  | "_" -- any
  | typeVar -- var
  | (lowerIdent &"?"? &"::"&) Type "=>" Type
  | longIdent (&"<"& TypesCommad &">"&)? -- constructor
  ; TODO object
  ; TODO class
  ; TODO alias?
  ; TODO package
  ; TODO extension

@passThrough
@ignoreNewlines
TupleTypes = Type (&"," Type)+ ","?

typeVar = "'" lowerIdent

Attribute = "[@@" lowerIdent Expr? "]"

@ignoreNewlines(false)
Statement =
  | "let" [rec]"rec"? ValueBinding (EOL "and" ValueBinding)* -- value
  | "let" "module" capIdent "=" ModuleDesc
  | "import" "*" "from" longCap
  | Expression

Expression =
  | Block
  | BinExp
  | Application -- application
  | FunExpr
  | SwitchExp
  | TryExp
  | "("& TupleBody &")" -- tuple
  | "`"&? longCap (&"("& Commas &")")? -- constructor
  | "{"& (RecordItem &",")+ RecordItem? &"}"
  | "[|"& (Expression &",")* Expression? &"|]" -- list
  | "["& (Expression &",")* Expression? &"]" -- list
  | Expression &"."& longIdent "=" Expression -- set_attr
  | Expression &"."& longIdent -- get_attr
  | Expression "?" Expression ":" Expression -- ternary
  | "while" Expression Block -- while
  | "for" -- for ; maybe ditch?
  | "new" longIdent -- new
  | Expression &"#"& lowerIdent -- send
  | lowerIdent "=" Expression -- instance_var
  | "assert" Expression -- assert
  | "lazy" Expression -- lazy
  | longIdent -- ident
  | constant -- const
  | "()" -- unit
  | "("& WrappedExpression &")" -- wrapped ; or constraint
  | "[%"& lowerIdent &"]" -- extension
  ; TODO coerce
  ; TODO override
  ; TODO poly
  ; TODO object
  ; TODO newtype
  ; TODO pack

@ignoreNewlines
@passThrough
WrappedExpression = Expression (&':' Type)?

@ignoreNewlines
@passThrough
TupleBody = Expression (&"," Expression)+ &","?

RecordItem = lowerIdent (&":" Expression)?

SwitchExp = "switch" Expression SwitchBody
SwitchBody = "{" "\n"+ (SwitchCase "\n"+)* "}"
SwitchCase = "case" MatchPattern ("with" [guard]Expression)? &":" "\n"* Expression?

TryExp = "try" Block "catch" SwitchBody

FunExpr =
  | "("& ValueArgs &")" "=>" Expression
  | Arg "=>" Expression

@ignoreNewlines(true)
Block = "{" Statement* "}"

Application = Expression &"("& AppArgs &")"

@ignoreNewlines
AppArgs = (FnArg &",")* FnArg?

;; maybe get operator precedence going?
BinExp = Expression binOp Expression

binOp =
  | "-"
  | "+"
  | "*"
  | "|>"
  | "=="
  | "!="
  | "!=="
  | "==="

longIdent = (capIdent ".")* lowerIdent
longCap = (capIdent ".")* capIdent ~"."

Commas = (Expression &",")* Expression?
FnArg =
  | "::"& lowerIdent -- punned
  | lowerIdent &"::"& Expression -- named
  | Expression -- anon

constant =
  | [val]int64 -- int
  | [val]string -- string
  | [val]char -- char

@leaf
capIdent = ~reserved 'A..Z' identchar*
@leaf
lowerIdent = ~reserved 'a..z' identchar*

identchar =
  | alpha
  | digit
  | "_"

@leaf
int64 =  digit+ ~identchar

@leaf
string = "\"" strchar* "\""
strchar =
  | "\\" any
  | ~"\"" ~"\n" ~"\\" any

@leaf
char = "'" charchar "'"
charchar =
  | "\\" any
  | ~"'" ~"\n" ~"\\" any

reserved =
  | "fun"
  | "let"
  | "and"
  | "as"
  | "type"
  | "exception"
  | "of"
  | "module"
  | "rec"
  | "open"
  | "import"
  | "try"
  | "catch"

alpha = 'a..z'
digit = '0..9'
