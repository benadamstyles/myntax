@lineComment("//")
@blockComment("/*", "*/")
Start = ModuleBody

@passThrough
@ignoreNewlines(false)
ModuleBody = __comment_eol? ([structures]Structure __comment_eol)* [structures]Structure? __comment_eol?

Structure =
  | "let" "module" capIdent "=" "{" ModuleBody "}" -- let_module
  | "let" "rec" "module" capIdent "=" "{" ModuleBody "}" ("\n" "and" capIdent "=" "{" ModuleBody "}")* -- let_rec_module
  | "let" [rec]"rec"? ValueBinding ("\n" "and" ValueBinding)* -- value
  | "type" TypeDeclaration ("\n"+ "and" TypeDeclaration)* -- type
  | "module" "type" capIdent "=" ModuleTypeDeclaration -- module_type
  | "exception" capIdent "of" Type
  | "import" "*" "from" longCap -- open
  | "include" "*" "from" longCap -- include
  | "[@@@" ident "]" -- attribute
  | "[%%" ident "]" -- extension
  | [expr]Statement [attrs]Attribute* -- eval
  ; class, class type
  ; typeext
  ; external "primitive"

ModuleTypeDeclaration = ident ; TODO

; TODO class field
; TODO class expr
; TODO class type field
; TODO class type

TypeDeclaration =
  | lowerIdent "=" longident "=" TypeDecl
  | lowerIdent "=" TypeDecl
  | lowerIdent

TypeDecl =
  | TypeVariant
  | TypeRecord
  | Type

@ignoreNewlines(false)
TypeVariant = 
  | "enum" "{" __comment_eol? (TypeVariantItem __comment_eol)* TypeVariantItem? "}"
  | capIdent ("|" capIdent)+ ; should I have this?

TypeVariantItem =
  | "case" capIdent "(" TypesCommad ")"
  | "case" capIdent

@ignoreNewlines
TypesCommad = (Type ",")* Type?

TypeRecord = "{" "\n"* (lowerIdent ":" Type "," "\n"*)* (lowerIdent ":" Type)? "\n"* "}"

ValueBinding =
  | ident "(" ValueArgs ")" "=>" Expression
  | ident Arg "=>" Expression
  | Pattern (":" Type)? "=" Expression

@passThrough
@ignoreNewlines
ValueArgs = (Arg "," "\n"?)* Arg?

Arg =
  | "::" ident ArgValue?
  | ident "::" Pattern ArgValue?
  | Pattern

ArgValue =
  | "=" "?"
  | "=" Expression

Pattern =
  | Pattern "as" ident
  | Pattern ":" Type
  | "()"
  | "_"
  | "(" Pattern ("," Pattern)+ ","? ")" -- tuple
  | "[" (Pattern ",")* Pattern? "]" -- list
  | "{" (ident (":" Pattern)? ",")* (ident (":" Pattern)?)? "}" -- record
  | ident

MatchPattern =
  | MatchPattern "as" ident
  | MatchPattern ":" Type
  | "()"
  | "_"
  | MatchPattern "|" MatchPattern -- or
  | "(" MatchPattern ":" Type ")" -- constraint
  | "lazy" MatchPattern -- lazy
  | "exception" MatchPattern -- exception
  | "[%" ident "]" -- extension
  | char ".." char -- interval
  | "(" MatchPattern ("," MatchPattern)+ ","? ")" -- tuple
  | "[|" (MatchPattern ",")* MatchPattern? "|]" -- array
  | "[" (MatchPattern ",")* MatchPattern? "]" -- list ; TODO ...rest
  | "`"? capIdent ("(" (MatchPattern ",")* MatchPattern? ")")? 
  | "{" (ident (":" MatchPattern)? ",")* (ident (":" MatchPattern)?)? "}" ; TODO _ for open flag
  | ident
  | constant
  ; Ppat_type
  ; Ppat_unpack

Type =
  | Type "as" typeVar -- alias
  | "(" TupleTypes ")" -- tuple
  | "_" -- any
  | typeVar
  | (lowerIdent "?"? "::") Type "=>" Type
  | longident ("<" TypesCommad ">")? -- constructor
  ; TODO object
  ; TODO class
  ; TODO alias?
  ; TODO package
  ; TODO extension

@passThrough
@ignoreNewlines
TupleTypes = Type ("," Type)+ ","?

typeVar = "'" lowerIdent

Attribute = "[@@" ident Expr? "]"

@ignoreNewlines(false)
Statement =
  | "let" [rec]"rec"? ValueBinding ("\n" "and" ValueBinding)* -- value
  | "let" "module" capIdent "=" "{" ModuleBody "}"
  | "import" "*" "from" longCap
  | Expression

Expression =
  | Block
  | BinExp
  | Application
  | FunExpr
  | SwitchExp
  | TryExp
  | "(" TupleBody ")" -- tuple
  | "`"? capIdent ("(" Commas ")")? -- constructor
  | "{" (RecordItem ",")+ RecordItem? "}"
  | "[|" (Expression ",")* Expression? "|]" -- list
  | "[" (Expression ",")* Expression? "]" -- list
  | Expression "." longIdent "=" Expression -- set_attr
  | Expression "." longIdent -- get_attr
  | Expression "?" Expression ":" Expression -- ternary
  | "while" Expression Block -- while
  | "for" -- for ; maybe ditch?
  | "new" longident -- new
  | Expression "#" lowerIdent -- send
  | lowerIdent "=" Expression -- instance_var
  | "assert" Expression -- assert
  | "lazy" Expression -- lazy
  | longident -- ident
  | constant -- const
  | "()" -- unit
  | "(" WrappedExpression ")" -- wrapped ; or constraint
  | "[%" ident "]" -- extension
  ; TODO coerce
  ; TODO override
  ; TODO poly
  ; TODO object
  ; TODO newtype
  ; TODO pack

@ignoreNewlines
@passThrough
WrappedExpression = Expression (':' Type)?

@ignoreNewlines
TupleBody = Expression ("," Expression)+ ","?

RecordItem = lowerIdent (":" Expression)?

SwitchExp = "switch" Expression SwitchBody
SwitchBody = "{" "\n"+ (SwitchCase "\n"+)* "}"
SwitchCase = "case" MatchPattern ("with" [guard]Expression)? ":" "\n"* Expression?

TryExp = "try" Block "catch" SwitchBody

FunExpr =
  | "(" "\n"* (Arg "," "\n"?)* Arg? "\n"* ")" "=>" Expression
  | Arg "=>" Expression

@ignoreNewlines(true)
Block = "{" Statement* "}"

Application = Expression "(" AppArgs ")"

@ignoreNewlines
AppArgs = (FnArg ",")* FnArg?

;; maybe get operator precedence going?
BinExp = Expression binOp Expression

binOp =
  | "-"
  | "+"
  | "*"
  | "|>"
  | "=="
  | "!="
  | "!=="
  | "==="

longident = (capIdent ".")* lowerIdent
longCap = (capIdent ".")* capIdent

Commas = (Expression ",")* Expression?
FnArg =
  | "::" lowerIdent
  | lowerIdent "::" Expression
  | Expression


constant =
  | int64
  | string
  | char

capIdent = ~reserved 'A..Z' identchar*
lowerIdent = ~reserved 'a..z' identchar*

ident = ~reserved ~digit identchar+
identchar =
  | alpha
  | digit
  | "_"

int64 =  digit+ ~identchar
string = "\"" strchar* "\""
strchar =
  | "\\" any
  | ~"\"" ~"\n" ~"\\" any

char = "'" charchar "'"
charchar =
  | "\\" any
  | ~"'" ~"\n" ~"\\" any

reserved =
  | "fun"
  | "let"
  | "and"
  | "as"
  | "type"
  | "exception"
  | "of"
  | "module"
  | "rec"
  | "open"
  | "import"
  | "try"
  | "catch"

alpha = 'a..z'
digit = '0..9'
