@lineComment(";")
@blockComment("(**", "*)")
Start = ModuleBody

@passThrough
@ignoreNewlines
ModuleBody = Structure*

Structure =
| "("& "let" LetPair &")" -- let
| "("& "let-rec" LetPair+ &")" -- let_rec
| "("& "type" TypeBody &")" -- type
| Expression -- eval

@ignoreNewlines
TypeBody = TypePair+

LetPair = [name]lowerIdent Expression

TypePair = TypeName TypeDecl

TypeName =
| "("& lowerIdent typeVariable+ &")" -- vbl
| lowerIdent -- plain

@ignoreNewlines
TypeDecl =
| "{"& TypeObjectItem+ &"}" -- record
| TypeConstructor+ -- constr
| CoreType -- core

TypeConstructor =
| longCap -- no_args
| "("& longCap CoreType+ &")" -- args

TypeObjectItem =
| attribute CoreType -- normal
| attribute -- punned

CoreType =
| longIdent -- constr_no_args
| typeVariable -- variable
| "("& longIdent CoreType+ &")" -- constructor

@leaf
typeVariable = '\'' lowerIdent

@ignoreNewlines
Expression =
| "("& "["& [index]Expression &"]" [array]Expression &")" -- array_index
| "("& [attr]string [object]Expression &")" -- js_object_attribute
| "("& [keyword]attribute [object]Expression &")" -- record_attribute
| Arrow -- arrow
| "("& "->>" [target]Expression ThreadItem+ &")" -- threading_last
| "("& "->" [target]Expression ThreadItem+ &")" -- threading
| Switch -- switch
| "("& [constr]longCap [args]Expression+ &")" -- constructor
| "("& "," [args]Expression+ &")" -- tuple
| "("& [fn]Expression [args]Expression+ &")" -- fn_call
| "["& [items]Expression* ("..."& [spread]Expression)? &"]" -- array_literal
| "{"& ("..."& [spread]Expression)? ObjectItem &"}" -- object_literal
| longCap -- empty_constr
| longIdent -- ident
| operator -- op
| constant -- const

Switch = "("& "switch" [target]Expression SwitchBody &")"

@ignoreNewlines
SwitchBody = SwitchCase+

SwitchCase = SwitchCond Expression
SwitchCond =
| Pattern "when" Expression -- when
| Pattern -- plain

ThreadItem =
| attribute -- attribute
| longIdent -- ident
| longCap -- emptyconstr
| "("& [constr]longCap [args]Expression+ &")" -- constructor
| "("& [fn]Expression [args]Expression+ &")" -- fn_call

ObjectItem =
| attribute Expression -- normal
| attribute -- punned

Arrow = "("& "=>" FnArgs [body]Expression* &")"

FnArgs =
| lowerIdent -- single
| "()" -- unit
| "_" -- ignored
| "["& FnArgItems &"]" -- multiple

@ignoreNewlines
FnArgItems = FnArg+

@ignoreNewlines
FnArg =
| argLabel "as" Pattern -- destructured
| argLabel &"="& Expression -- defaulted
| argLabel -- labeled
| Pattern -- unlabeled

@ignoreNewlines
Pattern =
| longIdent -- ident
| longCap -- empty_constr
| constant
| "()" -- unit
| "_" -- ignored
| "["& [item]Pattern* ("..."& [spread]Pattern)? &"]" -- array
| "("& "," [item]Pattern* &")" -- tuple
| "("& [constr]longCap [args]Pattern+ &")" -- constructor
| "{"& PatternObjectItem+ &"}" -- object
| "(|"& Pattern+ &")" -- or

PatternObjectItem =
| attribute Pattern -- normal
| attribute -- punned

@leaf
argLabel = '~' lowerIdent

@passThrough
Parened = "("& Expression & ")"

@leaf
attribute = ':' longIdent

longIdent = (longCap_ ".")? lowerIdent
longCap = longCap_ ~"."

longCap_ =
  | longCap_ "." capIdent -- dot
  | capIdent -- lident

constant =
  | [val]int64 -- int
  | [val]string -- string
  | [val]char -- char

@leaf
capIdent = ~(reserved ~identchar) 'A..Z' identchar*
@leaf
lowerIdent = ~(reserved ~identchar) 'a..z' identchar*

identchar =
  | alpha
  | digit
  | "_"

@leaf
int64 =  digit+ ~identchar

@leaf
string = "\"" strchar* "\""
strchar =
  | "\\" any
  | ~"\"" ~"\n" ~"\\" any

@leaf
char = "'" charchar "'"
charchar =
  | "\\" any
  | ~"'" ~"\n" ~"\\" any

reserved =
  | "fun"
  | "let"
  | "and"
  | "as"
  | "type"
  | "switch"
  | "exception"
  | "of"
  | "module"
  | "rec"
  | "open"
  | "import"
  | "try"
  | "catch"
  | "from"

alpha =
  | 'a..z'
  | 'A..Z'
digit = '0..9'

@leaf
operator = ~reservedOps opChar+

reservedOps =
| "=>"

opChar =
  |"!"
  |"$"
  |"%"
  |"&"
  |"*"
  |"+"
  |"-"
  |"."
  |"/"
  ;|":"
  |"<"
  |"="
  |">"
  |"?"
  |"@"
  |"^"
  |"|"
  |"~"